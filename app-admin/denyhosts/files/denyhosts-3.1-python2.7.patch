diff --git a/DenyHosts/deny_hosts.py b/DenyHosts/deny_hosts.py
index 52b07da..ce188a8 100644
--- a/DenyHosts/deny_hosts.py
+++ b/DenyHosts/deny_hosts.py
@@ -331,15 +331,15 @@ allowed based on your %s file"""  % (self.__prefs.get("HOSTS_DENY"),
                                           ENTRY_DELIMITER,
                                           output))
             fp.write("%s\n" % output)
-
-        plugin_deny = self.__prefs.get('PLUGIN_DENY')
-        if plugin_deny: plugin.execute(plugin_deny, new_hosts)
+        
         if self.__iptables:
            debug("Trying to create iptables rules")
            try:
               for host in new_hosts:
                   my_host = str(host)
-                  if self.__blockport:
+                  if ',' in self.__blockport:
+                      new_rule = self.__iptables + " -I INPUT -p tcp -m multiport --dports " + self.__blockport + " -s " + my_host + " -j DROP"
+                  elif self.__blockport:
                      new_rule = self.__iptables + " -I INPUT -p tcp --dport " + self.__blockport + " -s " + my_host + " -j DROP"
                   else:
                      new_rule = self.__iptables + " -I INPUT -s " + my_host + " -j DROP"
@@ -498,11 +498,23 @@ allowed based on your %s file"""  % (self.__prefs.get("HOSTS_DENY"),
                 msg = "WARNING: Could not add the following hosts to %s" % self.__prefs.get('HOSTS_DENY')
             else:
                 msg = "Added the following hosts to %s" % self.__prefs.get('HOSTS_DENY')
+                #run plugins since the rest has ran correctly
+                plugin_deny = self.__prefs.get('PLUGIN_DENY')
+                #check if PLUGIN_DENY is uncommented and has content
+                if plugin_deny:
+                    #check if there's a , delimiting multiple plugins
+                    if ',' in plugin_deny:
+                        #explode plugins by ,
+                        m_plugin_deny=plugin_deny.split(',')
+                        #loop through multiple plugins
+                        for m_plugin in m_plugin_deny:
+                            if m_plugin:
+                                plugin.execute(m_plugin.strip(), new_denied_hosts)
+                    else:
+                        plugin.execute(plugin_deny, new_denied_hosts)
+                        
             self.__report.add_section(msg, new_denied_hosts)
             if self.__sync_server: self.sync_add_hosts(new_denied_hosts)
-            plugin_deny = self.__prefs.get('PLUGIN_DENY')
-
-            if plugin_deny: plugin.execute(plugin_deny, new_denied_hosts)
 
         new_suspicious_logins = login_attempt.get_new_suspicious_logins()
         if new_suspicious_logins:
diff --git a/DenyHosts/regex.py b/DenyHosts/regex.py
index 5edf663..91ce18a 100644
--- a/DenyHosts/regex.py
+++ b/DenyHosts/regex.py
@@ -26,11 +26,14 @@ FAILED_ENTRY_REGEX7 = re.compile(r"""User (?P<user>.*) .*from (::ffff:)?(?P<host
 FAILED_ENTRY_REGEX8 = re.compile(r"""authentication error for (?P<user>.*) .*from (?P<host>.*)""")
 FAILED_ENTRY_REGEX9 = re.compile(r"""Invalid user (?P<user>.*) .*from (::ffff:)?(?P<host>\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3})""")
 
+
+FAILED_ENTRY_REGEX10 = re.compile(r"""Connection closed by (?P<host>\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}) \[preauth\]""")
+
 # these are reserved for future versions
-FAILED_ENTRY_REGEX10 = None
+FAILED_ENTRY_REGEX11 = None
 
 # this should match the highest num failed_entry_regex + 1
-FAILED_ENTRY_REGEX_NUM = 10 
+FAILED_ENTRY_REGEX_NUM = 11
 
 FAILED_ENTRY_REGEX_RANGE = list(range(1, FAILED_ENTRY_REGEX_NUM))
 FAILED_ENTRY_REGEX_MAP = {}
diff --git a/DenyHosts/report.py b/DenyHosts/report.py
index 9560eab..5ef823d 100644
--- a/DenyHosts/report.py
+++ b/DenyHosts/report.py
@@ -1,9 +1,6 @@
 import logging
 import re
 import socket
-# Removing this as it causes runtime errors on Python3.4
-# from types import ListType, TupleType
-import types
 from .util import is_true
 try:
     import syslog
@@ -39,8 +36,8 @@ class Report:
     def add_section(self, message, iterable):
         self.report += "%s:\n\n" % message
         for i in iterable:
-            # if type(i) in (TupleType, ListType):
-            if (type(i) is types.ListType) or (type(i) is types.TupleType):
+            # checks the item type (list or tuple)
+            if isinstance(i, list) or isinstance(i, tuple):
                 extra = ": %d\n" % i[1]
                 i = i[0]
             else:
diff --git a/denyhosts.conf b/denyhosts.conf
index ac40818..ba241d8 100644
--- a/denyhosts.conf
+++ b/denyhosts.conf
@@ -249,8 +249,9 @@ IPTABLES = /sbin/iptables
 # By default DenyHost will ask IPTables to block incoming connections
 # from an aggressive host on ALL ports. While this is usually a good
 # idea, it may prevent some botted machines from being able to access
-# services their legitmate users want, like a web server. To only
-# block specific ports, enable the following option.
+# services their legitmate users want, like a web server. To 
+# block specific ports, enable the following option. Multiple ports may
+# be specified using a comma as a delimiter ex: 21,22,3306
 # BLOCKPORT = 22
 #
 #######################################################################
@@ -473,7 +474,8 @@ AGE_RESET_INVALID=10d
 # PLUGIN_DENY: If set, this value should point to an executable
 # program that will be invoked when a host is added to the
 # HOSTS_DENY file.  This executable will be passed the host
-# that will be added as its only argument.
+# that will be added as its only argument. To run multiple plugins
+# separate the plugins by a comma ex /usr/bin/true,/usr/bin/false
 #
 #PLUGIN_DENY=/usr/bin/true
 #
diff --git a/denyhosts.py b/denyhosts.py
index a2b3389..c5eccca 100755
--- a/denyhosts.py
+++ b/denyhosts.py
@@ -25,7 +25,7 @@ info = logging.getLogger("denyhosts").info
 
 def usage():
     print("Usage:")
-    print("%s [-f logfile | --file=logfile] [ -c configfile | --config=configfile] [-i | --ignore] [-n | --noemail] [--purge] [--purge-all] [--purgeip=ip] [--migrate] [--daemon] [--sync] [--version]" % sys.argv[0])
+    print("%s [-f logfile | --file=logfile] [ -c configfile | --config configfile] [-i | --ignore] [-n | --noemail] [--purge] [--purge-all] [--purgeip ip] [--migrate] [--daemon] [--sync] [--version]" % sys.argv[0])
     print("\n\n")
     print(" --config: The pathname of the configuration file")
     print(" --file:   The name of log file to parse")
diff --git a/plugins/iptablesRemoveIp.sh b/plugins/iptablesRemoveIp.sh
new file mode 100644
index 0000000..9b451cc
--- /dev/null
+++ b/plugins/iptablesRemoveIp.sh
@@ -0,0 +1,88 @@
+#!/bin/bash
+#
+# Jose' Vargas <https://github.com/josev814>
+# To use this plugin, place it in a directory such as /var/local/bin, and make it executable
+# Then in /etc/denyhosts.conf look for PLUGIN_PURGE, and set the path to the file.
+# ex: PLUGIN_PURGE=/var/local/bin/iptablesRemoveIp.sh
+#
+# function to purge an ip from the iptables input
+function purgeFromIpTables () {
+  #get the iptables location and rule id from the args passed
+  ipTablesLocation=$1
+  ipRuleId=$2
+  
+  #remove the ip rule that was dropped from deny.hosts
+  $ipTablesLocation -D INPUT $ipRuleId
+}
+
+#function to write to the log file determined by /etc/denyhosts.conf
+function writeToLog () {
+  #Get log file location
+  logFileLocation=`cat /etc/denyhosts.conf | grep ^DAEMON_LOG\ = | awk '{ print $3 }'`
+  
+  #use the default logfileformat
+  #2016-07-13 21:11:14,380 - denyfileutil: INFO     num entries purged: 1
+  
+  # Get the current time for logging purposes
+  time=`date +"%Y-%m-%d %T"`
+
+  if [[ $1 == 1 ]]
+  then
+    #get the iprule args to write to log and delete from iprules from the passed argument
+    ipRule=$2
+    
+    #write what we're doing to the log
+    echo "$time,32 - iptablesRemoveIp       : INFO  Deleting $ipRule from iptables INPUT rules" >> $logFileLocation
+  else
+    echo "$time,34 - iptablesRemoveIp       : INFO  No rules to delete from iptables INPUT rules" >> $logFileLocation
+  fi
+}
+
+# Get the IP from the cli
+ip=$1
+
+# Get settings from denyhosts.conf
+ipTablesLocation=`cat /etc/denyhosts.conf | grep IPTABLES\ = | awk '{ print $3 }'`
+
+# Get the output of iptables INPUTS where it matches the given ip and action of DROP then return an array of the ids of the iprules
+ipRuleIds=(`$ipTablesLocation -L INPUT --line-numbers | grep $ip | grep DROP | awk '{ print $1 }'`)
+
+#change the IFS to explode content into an array using new line characters
+IFS=$'\r\n'
+# Get the output of iptables INPUTS where it matches the ip and DROP and get the target, protocol opt source and destination for the log
+ipRules=(`$ipTablesLocation -L INPUT --line-numbers | grep $ip | grep DROP | awk '{ print $2 $3 $4 $5 $6 }'`)
+
+#change IFS back to the original value
+unset IFS
+
+ruleCount=${#ipRuleIds[@]}
+
+#if the rule count is 1 then we don't have an array
+if [[ $ruleCount -eq 1 ]]
+then
+  writeToLog 1 $ipRules
+  purgeFromIpTables $ipTablesLocation $ipRuleIds
+else
+  #loop through the returned ip rules
+  #start at the highest rule and go to the lowest to prevent other rules from being deleted on accident.
+  while [[ $ruleCount -ge 0 ]]
+  do
+    #decrement ruleCount down 1 since arrays start at 0 and not one, 
+    #and keep reducing util we have 0 elements left
+    let ruleCount-=1
+    
+    ipRuleId=${ipRuleIds[ruleCount]}
+    ipRule=${ipRules[ruleCount]}
+
+    #as long as the ipRuleId is greater than 0 it's valid
+    if [[ $ipRuleId -gt 0 ]]
+    then
+      writeToLog 1 "$ipRules"
+      purgeFromIpTables $ipTablesLocation $ipRuleIds
+    else
+      #write that nothing was done to ipTables
+      writeToLog 0
+    fi
+    
+  done
+fi
diff --git a/plugins/sendToSlack.py b/plugins/sendToSlack.py
new file mode 100644
index 0000000..2aa02f1
--- /dev/null
+++ b/plugins/sendToSlack.py
@@ -0,0 +1,53 @@
+#!/usr/bin/python
+#
+# Jose' Vargas <https://github.com/josev814>
+# This plugin allows deny host to send a blocked ip to slack as a notification
+# To enable the plugin edit /etc/denyhosts.conf
+# Uncomment PLUGIN_DENY and point it to the location of this file
+# Edit lines 16 and 18 to your slack web hook url and channel
+# chmod +x this file so that it's executable, or the logs will show plugin returned 32256
+# Tested on Python 2.7.9
+#
+import sys
+import urllib2
+import socket
+
+# Enable/Disable the option to include/exclude ips in slack messages
+enableIps=False
+
+# set the slack options
+#Slack Web Hook ex: https://hooks.slack.com/services/xxxxxxx/xxxxxxxxx/xxxxxxxxxxxxxxxxxxxx
+slackWebHook=''
+#channel to post in slack, include the # in front of the channel ex: #systems
+channel=''
+
+# Get Server Info
+serverName=socket.gethostbyname_ex(socket.gethostname())[0]
+
+if enableIps:
+        serverIps=socket.gethostbyname_ex(socket.gethostname())[2]
+        if len(serverIps) > 1:
+                externalServerIp=socket.gethostbyname_ex(socket.gethostname())[2][1]
+                internalServerIp=socket.gethostbyname_ex(socket.gethostname())[2][0]
+                # Set the Message that's sent
+                message="%s ip blocked on %s (%s / %s)" % ( sys.argv[1], serverName, externalServerIp, internalServerIp )
+        else:
+                serverIp=socket.gethostbyname_ex(socket.gethostname())[2][0]
+                # Set the Message that's sent
+                message="%s ip blocked on %s (%s)" % ( sys.argv[1], serverName, serverIp )
+else:
+        message="%s ip blocked on %s" % ( sys.argv[1], serverName )
+        
+
+#if channel is set use the channel defined, otherwise post to the channel the webhook was made for
+if channel != "":
+        data='payload={"text":"' + message + '","channel":"' + channel + '"}'
+else:
+        data='payload={"text":"' + message + '"}'
+
+if slackWebHook != "":
+        request = urllib2.Request(slackWebHook, data)
+        call = urllib2.urlopen(request)
+        call.close()
+
+sys.exit(0)
